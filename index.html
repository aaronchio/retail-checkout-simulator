<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Chio Checkout Flow Simulator</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
:root {
  --bg: #f8fafc;
  --panel: #ffffff;
  --border: #e2e8f0;
  --accent: #3b82f6;
  --accent-hover: #2563eb;
  --accent-light: #eff6ff;
  --text: #0f172a;
  --text-secondary: #64748b;
  --success: #10b981;
  --warning: #f59e0b;
  --danger: #ef4444;
  --purple: #8b5cf6;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
}
.app {
  max-width: 1400px;
  margin: 0 auto;
  padding: 24px;
}
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 0 28px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 28px;
}
.logo {
  font-weight: 700;
  font-size: 1.5rem;
  color: var(--text);
  letter-spacing: -0.02em;
}
.logo span { color: var(--accent); }
.badge {
  display: inline-block;
  font-size: 0.7rem;
  background: var(--accent-light);
  color: var(--accent);
  padding: 4px 10px;
  border-radius: 12px;
  font-weight: 600;
  margin-left: 12px;
  vertical-align: middle;
}
.layout {
  display: grid;
  grid-template-columns: 320px 1fr;
  gap: 24px;
  align-items: start;
}

/* Controls */
.controls {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 24px;
  position: sticky;
  top: 24px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
  max-height: 92vh;
  overflow-y: auto;
}
.controls::-webkit-scrollbar { width: 6px; }
.controls::-webkit-scrollbar-track { background: transparent; }
.controls::-webkit-scrollbar-thumb { background: var(--border); border-radius: 10px; }
.controls h2 {
  font-size: 0.875rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--text-secondary);
  margin-bottom: 20px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border);
}
.cg { margin-bottom: 20px; }
.cg label {
  display: flex;
  justify-content: space-between;
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--text);
  margin-bottom: 8px;
}
.cg label span {
  color: var(--accent);
  font-weight: 600;
}
.cg .hint {
  display: flex;
  justify-content: space-between;
  font-size: 0.75rem;
  color: var(--text-secondary);
  margin-top: 6px;
}
input[type=range] {
  -webkit-appearance: none;
  width: 100%;
  height: 6px;
  background: var(--border);
  border-radius: 10px;
  outline: none;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 18px;
  height: 18px;
  background: var(--accent);
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(59,130,246,0.3);
  transition: all 0.15s;
}
input[type=range]::-webkit-slider-thumb:hover {
  background: var(--accent-hover);
  transform: scale(1.1);
}
.tg {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.tb {
  flex: 1;
  min-width: 85px;
  padding: 8px 14px;
  background: var(--bg);
  border: 1.5px solid var(--border);
  color: var(--text-secondary);
  font-family: 'Inter', sans-serif;
  font-size: 0.8rem;
  font-weight: 500;
  cursor: pointer;
  border-radius: 8px;
  transition: all 0.2s;
  text-align: center;
}
.tb:hover { border-color: var(--accent); color: var(--text); }
.tb.on {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}
.sep {
  border: none;
  border-top: 1px solid var(--border);
  margin: 20px 0;
}

/* Lane rows */
.lane-row { margin-bottom: 16px; }
.lane-row-label {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  font-weight: 500;
  color: var(--text);
  margin-bottom: 8px;
}
.lane-row-label b {
  color: var(--accent);
  font-weight: 600;
}

/* Buttons */
.btn-primary {
  width: 100%;
  padding: 12px;
  margin-top: 8px;
  background: var(--accent);
  color: white;
  border: none;
  font-family: 'Inter', sans-serif;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  border-radius: 8px;
  transition: all 0.2s;
  box-shadow: 0 2px 4px rgba(59,130,246,0.2);
}
.btn-primary:hover {
  background: var(--accent-hover);
  box-shadow: 0 4px 8px rgba(59,130,246,0.3);
  transform: translateY(-1px);
}
.btn-secondary {
  width: 100%;
  padding: 10px;
  margin-top: 8px;
  background: transparent;
  color: var(--text-secondary);
  border: 1.5px solid var(--border);
  font-family: 'Inter', sans-serif;
  font-size: 0.85rem;
  font-weight: 500;
  cursor: pointer;
  border-radius: 8px;
  transition: all 0.2s;
}
.btn-secondary:hover {
  border-color: var(--text-secondary);
  color: var(--text);
}

/* Stats */
.stats {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  margin-bottom: 24px;
}
.sc {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.sl {
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--text-secondary);
  margin-bottom: 8px;
}
.sv {
  font-size: 2rem;
  font-weight: 700;
  line-height: 1;
  color: var(--text);
}
.sc:nth-child(1) .sv { color: var(--accent); }
.sc:nth-child(2) .sv { color: var(--success); }
.sc:nth-child(3) .sv { color: var(--warning); }
.sc:nth-child(4) .sv { color: var(--purple); }
.su {
  font-size: 0.75rem;
  color: var(--text-secondary);
  margin-top: 4px;
}

/* Canvas */
.simbox {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.simhdr {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 20px;
  border-bottom: 1px solid var(--border);
  background: var(--bg);
}
.simtitle {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text);
}
.simstatus {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 0.8rem;
  color: var(--text-secondary);
}
.dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--text-secondary);
}
.dot.run {
  background: var(--success);
  box-shadow: 0 0 8px rgba(16,185,129,0.5);
  animation: pulse 1.5s infinite;
}
.dot.stop { background: var(--danger); }
@keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.5; } }
canvas { display: block; width: 100%; background: #fafbfc; }
.speedrow {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 12px 20px;
  border-top: 1px solid var(--border);
  background: var(--bg);
}
.speedlbl {
  font-size: 0.8rem;
  font-weight: 500;
  color: var(--text);
  white-space: nowrap;
}
.speedrow input { flex: 1; }

/* Legend */
.legend {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  padding: 14px 20px;
  border: 1px solid var(--border);
  border-radius: 12px;
  margin-top: 16px;
  font-size: 0.8rem;
  color: var(--text-secondary);
  background: var(--panel);
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.li { display: flex; align-items: center; gap: 8px; }
.ld { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }

/* Log */
.log {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  margin-top: 16px;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.loghdr {
  padding: 12px 20px;
  border-bottom: 1px solid var(--border);
  font-size: 0.8rem;
  font-weight: 500;
  color: var(--text);
  background: var(--bg);
  display: flex;
  justify-content: space-between;
}
.logbody {
  height: 100px;
  overflow-y: auto;
  padding: 10px 20px;
  font-size: 0.75rem;
  line-height: 1.8;
  font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
}
.logbody::-webkit-scrollbar { width: 6px; }
.logbody::-webkit-scrollbar-thumb { background: var(--border); border-radius: 10px; }
.le { color: var(--text-secondary); }
.le .ts { color: var(--accent); margin-right: 10px; font-weight: 500; }
.le.join .ev { color: var(--success); }
.le.done .ev { color: var(--warning); }

/* KPI Dashboard */
.kpi-panel {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 24px;
  margin-top: 16px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.kpi-header {
  font-size: 0.875rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--text-secondary);
  margin-bottom: 20px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border);
}
.kpi-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 16px;
}
.kpi-card {
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 16px;
  position: relative;
}
.kpi-card-title {
  font-size: 0.75rem;
  font-weight: 500;
  color: var(--text-secondary);
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.kpi-icon {
  font-size: 1rem;
}
.kpi-value {
  font-size: 1.8rem;
  font-weight: 700;
  color: var(--text);
  margin-bottom: 4px;
}
.kpi-subtitle {
  font-size: 0.7rem;
  color: var(--text-secondary);
}
.kpi-bar {
  width: 100%;
  height: 6px;
  background: var(--border);
  border-radius: 3px;
  margin-top: 10px;
  overflow: hidden;
}
.kpi-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.3s ease;
}
.kpi-good { background: var(--success); }
.kpi-warn { background: var(--warning); }
.kpi-bad { background: var(--danger); }
.kpi-insight {
  font-size: 0.7rem;
  color: var(--text-secondary);
  margin-top: 8px;
  font-style: italic;
}
.lane-util-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 8px;
  margin-top: 8px;
}
.lane-util-item {
  font-size: 0.7rem;
  padding: 6px 8px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 4px;
  text-align: center;
}
.lane-util-label {
  color: var(--text-secondary);
  display: block;
  margin-bottom: 3px;
}
.lane-util-val {
  font-weight: 600;
  color: var(--text);
}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="logo">CHIO CHECKOUT<span>SIM</span><span class="badge">V3</span></div>
    <div style="font-size:.62rem;color:var(--dim);letter-spacing:.1em;">RETAIL QUEUE SIMULATOR</div>
  </header>

  <div class="layout">
    <!-- â”€â”€ CONTROLS â”€â”€ -->
    <div class="controls">
      <h2>âš™ Parameters</h2>

      <div class="cg">
        <label>Checkout Lanes <span id="vLanes">4</span></label>
        <input type="range" id="cLanes" min="1" max="10" value="4">
      </div>

      <div class="cg">
        <label>Customers Arriving <span id="vArrival">6</span>/min</label>
        <input type="range" id="cArrival" min="1" max="60" value="6">
        <div class="hint"><span>1 (quiet)</span><span>60 (rush hour)</span></div>
      </div>

      <hr class="sep">

      <div class="cg">
        <label style="margin-bottom:9px;display:block;color:var(--accent);">Lane Service Time (seconds)</label>
        <div style="font-size:.6rem;color:var(--dim);margin-bottom:10px;">How many seconds to fully serve one customer per lane. 0 = instant, 600 = 10 min.</div>
        <div id="laneSliders"></div>
      </div>

      <hr class="sep">

      <div class="cg">
        <label style="margin-bottom:9px;">Queue Layout</label>
        <div class="tg">
          <button class="tb on" data-queue="single">Single Feed</button>
          <button class="tb" data-queue="snake">Snake</button>
          <button class="tb" data-queue="dedicated">Per Lane</button>
        </div>
      </div>

      <div class="cg">
        <label style="margin-bottom:9px;">Customer Mix</label>
        <div class="tg">
          <button class="tb on" data-mix="normal">Normal</button>
          <button class="tb" data-mix="slow">Slow</button>
          <button class="tb" data-mix="express">Express</button>
        </div>
      </div>

      <button class="btn-primary" id="btnRun">â–¶ START SIMULATION</button>
      <button class="btn-secondary" id="btnReset">â†º Reset</button>
    </div>

    <!-- â”€â”€ MAIN AREA â”€â”€ -->
    <div>
      <div class="stats">
        <div class="sc"><div class="sl">Avg Wait</div><div class="sv" id="sWait">0</div><div class="su">seconds</div></div>
        <div class="sc"><div class="sl">Served</div><div class="sv" id="sServed">0</div><div class="su">customers</div></div>
        <div class="sc"><div class="sl">Throughput</div><div class="sv" id="sTput">0</div><div class="su">per minute</div></div>
        <div class="sc"><div class="sl">Queuing</div><div class="sv" id="sQueue">0</div><div class="su">waiting</div></div>
      </div>

      <div class="simbox">
        <div class="simhdr">
          <div class="simtitle">Live Store Floor</div>
          <div class="simstatus">
            <div class="dot stop" id="dotStatus"></div>
            <span id="txtStatus">Stopped</span>
            <span style="margin-left:12px;color:var(--accent);" id="txtTime">T+0s</span>
          </div>
        </div>
        <canvas id="simCanvas" height="500"></canvas>
        <div class="speedrow">
          <span class="speedlbl">Sim Speed</span>
          <input type="range" id="cSimSpeed" min="0.5" max="6" step="0.5" value="1">
          <span style="font-size:.62rem;color:var(--accent);min-width:28px;" id="vSimSpeed">1Ã—</span>
        </div>
      </div>

      <div class="legend">
        <div class="li"><div class="ld" style="background:#3b82f6;"></div>Entering</div>
        <div class="li"><div class="ld" style="background:#10b981;"></div>Waiting in line</div>
        <div class="li"><div class="ld" style="background:#f59e0b;"></div>Walking to register</div>
        <div class="li"><div class="ld" style="background:#ef4444;"></div>Being served</div>
        <div class="li"><div class="ld" style="background:#8b5cf6;"></div>Leaving</div>
        <div class="li"><span style="color:var(--dim);">Ring size = basket size</span></div>
      </div>

      <div class="log">
        <div class="loghdr"><span>Event Log</span><span id="logCount" style="color:var(--accent);">0 events</span></div>
        <div class="logbody" id="logBody"></div>
      </div>
    
      <!-- KPI Dashboard -->
      <div class="kpi-panel">
        <div class="kpi-header">ğŸ“Š Key Performance Indicators</div>
        <div class="kpi-grid">
          
          <!-- 1. Lane Utilization -->
          <div class="kpi-card">
            <div class="kpi-card-title"><span class="kpi-icon">âš¡</span>Lane Utilization</div>
            <div class="kpi-value" id="kpi-util">0%</div>
            <div class="kpi-subtitle">Average across all lanes</div>
            <div class="kpi-bar">
              <div class="kpi-bar-fill kpi-good" id="kpi-util-bar" style="width:0%"></div>
            </div>
            <div class="lane-util-grid" id="kpi-util-lanes"></div>
          </div>

          <!-- 2. Peak Wait Time -->
          <div class="kpi-card">
            <div class="kpi-card-title"><span class="kpi-icon">â±ï¸</span>Peak Wait Time</div>
            <div class="kpi-value" id="kpi-peak">0s</div>
            <div class="kpi-subtitle">Longest customer wait</div>
            <div class="kpi-bar">
              <div class="kpi-bar-fill" id="kpi-peak-bar" style="width:0%"></div>
            </div>
            <div class="kpi-insight" id="kpi-peak-insight"></div>
          </div>

          <!-- 3. Service Level -->
          <div class="kpi-card">
            <div class="kpi-card-title"><span class="kpi-icon">ğŸ¯</span>Service Level (3min target)</div>
            <div class="kpi-value" id="kpi-sla">0%</div>
            <div class="kpi-subtitle"><span id="kpi-sla-count">0</span> customers served within target</div>
            <div class="kpi-bar">
              <div class="kpi-bar-fill" id="kpi-sla-bar" style="width:0%"></div>
            </div>
          </div>

          <!-- 4. Abandonment Risk -->
          <div class="kpi-card">
            <div class="kpi-card-title"><span class="kpi-icon">âš ï¸</span>Abandonment Risk</div>
            <div class="kpi-value" id="kpi-abandon">0%</div>
            <div class="kpi-subtitle"><span id="kpi-abandon-count">0</span> customers waiting 5+ min</div>
            <div class="kpi-bar">
              <div class="kpi-bar-fill kpi-bad" id="kpi-abandon-bar" style="width:0%"></div>
            </div>
          </div>

          <!-- 5. What-If Recommendation -->
          <div class="kpi-card">
            <div class="kpi-card-title"><span class="kpi-icon">ğŸ’¡</span>Optimization Insight</div>
            <div class="kpi-value" style="font-size:1.2rem;" id="kpi-whatif">Analyzing...</div>
            <div class="kpi-subtitle" id="kpi-whatif-detail">Run simulation to see recommendations</div>
          </div>

        </div>
      </div>

    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CANVAS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
function resizeCanvas() { canvas.width = canvas.parentElement.clientWidth; }
resizeCanvas();
window.addEventListener('resize', () => { resizeCanvas(); buildLayout(); renderFrame(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PARAMS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const P = {
  numLanes: 4,
  arrivalRate: 6,      // customers per minute
  queueType: 'single', // 'single' | 'snake' | 'dedicated'
  custMix: 'normal',   // 'normal' | 'slow' | 'express'
  simSpeed: 1,
};

// Per-lane service time in real seconds (how long to fully serve one customer)
let laneTime = [30, 30, 30, 30];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LAYOUT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let L = {};
let SNAKE = [];  // snake path slots [{x,y}]
const SLOT_GAP = 18;
const PAL = ['#00e5ff','#a8ff3e','#fbbf24','#c084fc','#fb7185','#34d399','#f97316','#60a5fa'];

function buildLayout() {
  const W = canvas.width, H = canvas.height;
  const PAD = 16, RH = 54, RY = PAD + 8;
  const WALL = RY + RH + 8;
  const FLOOR = H - 30;
  const LW = Math.floor((W - PAD * 2) / P.numLanes);

  const regs = [];
  for (let i = 0; i < P.numLanes; i++) {
    const cx = PAD + i * LW + LW / 2;
    regs.push({
      id: i, cx,
      rx: PAD + i * LW + 5, ry: RY,
      rw: LW - 10, rh: RH,
      serveX: cx, serveY: WALL + 18,
      qColX: cx,
      busy: false, serving: null,
      laneQ: [],
    });
  }

  L = { W, H, PAD, RH, RY, WALL, FLOOR, LW, regs };
  buildSnake();
}

function buildSnake() {
  SNAKE = [];
  const { W, PAD, FLOOR } = L;
  // Snake only in the bottom ~40% of floor space, above entrance
  const ZONE_TOP  = FLOOR - 160;
  const ZONE_BOT  = FLOOR - 22;
  const ROW_H = 20, usW = W - PAD * 2;
  for (let row = 0; ZONE_TOP + row * ROW_H < ZONE_BOT; row++) {
    const y = ZONE_TOP + row * ROW_H + 10;
    const ltr = row % 2 === 0;
    for (let col = 0; col < 12; col++) {
      const frac = (col + 0.5) / 12;
      SNAKE.push({ x: PAD + (ltr ? frac : 1 - frac) * usW, y });
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  QUEUE TARGETS
//
//  The queue is a HORIZONTAL LINE at the bottom of
//  the canvas, just above the entrance marker.
//
//  Slot 0 = front of line (LEFT side, nearest register)
//  Slot N = back of line  (RIGHT side, new arrivals join here)
//
//  Snake mode: zigzags back-and-forth in the bottom zone.
//  Per-lane:   each lane has its own horizontal sub-row.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Y position of the queue line (single row of people)
function queueY() { return L.FLOOR - 30; }

// X position for a slot in the master queue (single/snake)
// Slots spread LEFT â†’ RIGHT across the full canvas width
function masterTarget(slot) {
  if (P.queueType === 'snake') {
    const s = SNAKE[Math.min(slot, SNAKE.length - 1)];
    return { x: s.x, y: s.y };
  }
  // Single feed: one horizontal line, centred, spreading outward from centre
  const QY = queueY();
  const totalW = L.W - L.PAD * 4;
  const spacing = Math.min(SLOT_GAP, totalW / Math.max(masterQ.length, 1));
  // Anchor the FRONT of the line to left-centre, grow rightward
  const startX = L.PAD * 2;
  return { x: startX + slot * spacing, y: QY };
}

// Per-lane: each lane gets its own row, stacked above each other if needed
function laneTarget(laneId, slot) {
  const QY = queueY();
  const r = L.regs[laneId];
  // Each lane's queue fans out horizontally below its register column
  const spacing = Math.min(SLOT_GAP, (L.W - L.PAD*2) / Math.max(r.laneQ.length, 1));
  const startX = r.cx - (r.laneQ.length * spacing) / 2;
  return { x: startX + slot * spacing, y: QY - laneId * 4 };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SIM STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let running = false, rafId = null, lastTs = 0;
let simTime = 0, served = 0;
let waitLog = [], tputLog = [];
let masterQ = [];
let allC = [];
let nextId = 0, nextArrival = 0, logN = 0;

// KPI tracking
let peakWait = 0;
let slaTarget = 180;  // 3 minutes in seconds
let slaMetCount = 0;
let laneUtilHistory = [];  // [{laneId, busyTime, totalTime}]


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CUSTOMER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function mkCust() {
  let sm = 0.8 + Math.random() * 0.4;
  if (P.custMix === 'slow')    sm = 0.35 + Math.random() * 0.3;
  if (P.custMix === 'express') sm = 1.5  + Math.random() * 1.0;
  return {
    id: nextId++,
    basket: 5 + Math.floor(Math.random() * 30),
    sm,
    col: PAL[nextId % PAL.length],
    x: L.PAD + Math.random() * (L.W - L.PAD * 2),
    y: L.FLOOR,
    tx: 0, ty: 0,
    // entering â†’ queuing â†’ walking â†’ serving â†’ leaving â†’ done
    state: 'entering',
    lane: -1, slot: -1,
    svcProg: 0, svcTotal: 0,
    waitStart: 0, opacity: 1,
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPAWN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function spawn() {
  const c = mkCust();
  allC.push(c);

  if (P.queueType === 'dedicated') {
    let best = 0, bestLen = Infinity;
    L.regs.forEach((r, i) => {
      const n = r.laneQ.length + (r.busy ? 1 : 0);
      if (n < bestLen) { bestLen = n; best = i; }
    });
    c.lane = best;
    L.regs[best].laneQ.push(c);
    // Recompute all slots so spacing adjusts as queue grows
    L.regs[best].laneQ.forEach((x, i) => {
      x.slot = i;
      const t = laneTarget(best, i);
      x.tx = t.x; x.ty = t.y;
    });
    c.slot = L.regs[best].laneQ.length - 1;
  } else {
    c.slot = masterQ.length;
    masterQ.push(c);
    // Recompute all slots so spacing adjusts as queue grows
    masterQ.forEach((x, i) => {
      x.slot = i;
      const t = masterTarget(i);
      x.tx = t.x; x.ty = t.y;
    });
  }

  c.waitStart = simTime;
  log('join', `#${c.id} arrived`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ASSIGN QUEUE â†’ REGISTER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function assign() {
  if (P.queueType === 'dedicated') {
    L.regs.forEach(r => {
      if (!r.busy && r.laneQ.length > 0) serve(r, r.laneQ[0], true);
    });
  } else {
    L.regs.forEach(r => {
      if (!r.busy && masterQ.length > 0) serve(r, masterQ[0], false);
    });
  }
}

function serve(reg, c, dedicated) {
  if (dedicated) {
    reg.laneQ.shift();
    // Recompute spacing now that queue is shorter
    reg.laneQ.forEach((x, i) => {
      x.slot = i;
      const t = laneTarget(reg.id, i);
      x.tx = t.x; x.ty = t.y;
    });
  } else {
    masterQ.shift();
    // Recompute spacing now that queue is shorter
    masterQ.forEach((x, i) => {
      x.slot = i;
      const t = masterTarget(i);
      x.tx = t.x; x.ty = t.y;
    });
  }

  reg.busy = true; reg.serving = c;
  c.state = 'walking'; c.lane = reg.id;
  c.tx = reg.serveX; c.ty = reg.serveY;

  // Service time = lane's configured seconds, scaled by customer speedMult
  const base = laneTime[reg.id] !== undefined ? laneTime[reg.id] : 30;
  c.svcTotal = base === 0 ? 0.01 : base / c.sm;
  c.svcProg = 0;

  const waited = Math.round(simTime - c.waitStart);
  waitLog.push(waited);
  if (waitLog.length > 300) waitLog.shift();
  tputLog.push(simTime);
  log('done', `Lane ${reg.id+1} â†’ #${c.id} (waited ${waited}s)`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UPDATE CUSTOMER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const WALK = 95;

function tick(c, dt) {
  const dx = c.tx - c.x, dy = c.ty - c.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if (dist > 1) {
    const step = Math.min(WALK * dt, dist);
    c.x += dx / dist * step;
    c.y += dy / dist * step;
  } else {
    c.x = c.tx; c.y = c.ty;
    if (c.state === 'entering') c.state = 'queuing';
    if (c.state === 'walking')  c.state = 'serving';
  }

  if (c.state === 'serving') {
    c.svcProg += dt;
    if (c.svcProg >= c.svcTotal) finish(c);
  }

  if (c.state === 'leaving') {
    const d = Math.sqrt((c.tx-c.x)**2 + (c.ty-c.y)**2);
    if (d < 50) { c.opacity -= dt * 2; if (c.opacity <= 0) c.state = 'done'; }
  }
}

function finish(c) {
  const r = L.regs[c.lane];
  r.busy = false; r.serving = null;
  c.state = 'leaving';
  c.tx = r.cx + (Math.random() - 0.5) * 80;
  c.ty = L.FLOOR + 40;
  served++;
  log('done', `#${c.id} done âœ“`);
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UPDATE KPIs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateKPIs() {
  // 1. Lane Utilization - track time each lane is busy
  L.regs.forEach(reg => {
    if (reg.busy) {
      if (!reg.busyStart) reg.busyStart = simTime;
    } else {
      if (reg.busyStart) {
        const busyDuration = simTime - reg.busyStart;
        if (!reg.totalBusy) reg.totalBusy = 0;
        reg.totalBusy += busyDuration;
        reg.busyStart = null;
      }
    }
  });

  const avgUtil = L.regs.reduce((sum, r) => {
    const busy = (r.totalBusy || 0) + (r.busyStart ? simTime - r.busyStart : 0);
    const total = simTime > 0 ? simTime : 1;
    return sum + (busy / total * 100);
  }, 0) / L.regs.length;

  document.getElementById('kpi-util').textContent = Math.round(avgUtil) + '%';
  document.getElementById('kpi-util-bar').style.width = Math.min(avgUtil, 100) + '%';
  
  // Color based on efficiency (70-85% is optimal)
  const utilBar = document.getElementById('kpi-util-bar');
  if (avgUtil >= 70 && avgUtil <= 85) {
    utilBar.className = 'kpi-bar-fill kpi-good';
  } else if (avgUtil < 70) {
    utilBar.className = 'kpi-bar-fill kpi-warn';
  } else {
    utilBar.className = 'kpi-bar-fill kpi-bad';
  }

  // Per-lane breakdown
  const utilLanes = document.getElementById('kpi-util-lanes');
  utilLanes.innerHTML = L.regs.map(r => {
    const busy = (r.totalBusy || 0) + (r.busyStart ? simTime - r.busyStart : 0);
    const total = simTime > 0 ? simTime : 1;
    const pct = Math.round(busy / total * 100);
    return `<div class="lane-util-item"><span class="lane-util-label">L${r.id+1}</span><span class="lane-util-val">${pct}%</span></div>`;
  }).join('');

  // 2. Peak Wait Time
  peakWait = Math.max(peakWait, ...waitLog);
  document.getElementById('kpi-peak').textContent = peakWait + 's';
  const peakPct = Math.min((peakWait / 600) * 100, 100);  // scale to 10min max
  document.getElementById('kpi-peak-bar').style.width = peakPct + '%';
  
  const peakBar = document.getElementById('kpi-peak-bar');
  if (peakWait < 120) {
    peakBar.className = 'kpi-bar-fill kpi-good';
    document.getElementById('kpi-peak-insight').textContent = 'âœ“ Excellent service times';
  } else if (peakWait < 300) {
    peakBar.className = 'kpi-bar-fill kpi-warn';
    document.getElementById('kpi-peak-insight').textContent = 'âš ï¸ Some customers waiting longer';
  } else {
    peakBar.className = 'kpi-bar-fill kpi-bad';
    document.getElementById('kpi-peak-insight').textContent = 'â›” Critical wait times detected';
  }

  // 3. Service Level Achievement (% served within 3min)
  const totalServedCount = waitLog.length;
  slaMetCount = waitLog.filter(w => w <= slaTarget).length;
  const slaPct = totalServedCount > 0 ? (slaMetCount / totalServedCount * 100) : 0;
  document.getElementById('kpi-sla').textContent = Math.round(slaPct) + '%';
  document.getElementById('kpi-sla-count').textContent = slaMetCount;
  document.getElementById('kpi-sla-bar').style.width = Math.min(slaPct, 100) + '%';
  
  const slaBar = document.getElementById('kpi-sla-bar');
  if (slaPct >= 95) {
    slaBar.className = 'kpi-bar-fill kpi-good';
  } else if (slaPct >= 80) {
    slaBar.className = 'kpi-bar-fill kpi-warn';
  } else {
    slaBar.className = 'kpi-bar-fill kpi-bad';
  }

  // 4. Abandonment Risk (customers waiting 5+ min)
  const queueing = allC.filter(c => c.state === 'queuing');
  const longWaiters = queueing.filter(c => simTime - c.waitStart > 300);
  const abandonPct = queueing.length > 0 ? (longWaiters.length / queueing.length * 100) : 0;
  document.getElementById('kpi-abandon').textContent = Math.round(abandonPct) + '%';
  document.getElementById('kpi-abandon-count').textContent = longWaiters.length;
  document.getElementById('kpi-abandon-bar').style.width = Math.min(abandonPct, 100) + '%';

  // 5. What-If Recommendation
  let recommendation = '';
  let detail = '';
  
  if (simTime < 30) {
    recommendation = 'Analyzing...';
    detail = 'Run simulation for 30+ seconds';
  } else if (avgUtil < 50) {
    const excess = L.regs.filter(r => {
      const busy = (r.totalBusy || 0) + (r.busyStart ? simTime - r.busyStart : 0);
      return (busy / simTime * 100) < 40;
    }).length;
    recommendation = excess > 0 ? `Close ${excess} lane${excess>1?'s':''}` : 'Optimal staffing';
    detail = excess > 0 ? `Save labor cost - ${excess} lane${excess>1?'s are':' is'} underutilized` : 'Current staffing matches demand';
  } else if (avgUtil > 90) {
    const needed = Math.ceil((avgUtil - 85) / 15);
    recommendation = `Add ${needed} lane${needed>1?'s':''}`;
    detail = `Reduce wait times by ~${Math.round((avgUtil - 85) / avgUtil * 100)}%`;
  } else if (peakWait > 300) {
    recommendation = 'Speed up slow lanes';
    detail = `Lane ${L.regs.reduce((slowest, r) => (laneTime[r.id] || 30) > (laneTime[slowest.id] || 30) ? r : slowest).id + 1} is bottleneck`;
  } else if (abandonPct > 10) {
    recommendation = 'Open express lane';
    detail = `${longWaiters.length} customers at risk of abandoning`;
  } else {
    recommendation = 'âœ“ Optimal setup';
    detail = 'System running efficiently';
  }

  document.getElementById('kpi-whatif').textContent = recommendation;
  document.getElementById('kpi-whatif-detail').textContent = detail;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SIM STEP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function step(dtReal) {
  const dt = dtReal * P.simSpeed;
  simTime += dt;

  nextArrival -= dt;
  if (nextArrival <= 0) {
    nextArrival = (60 / P.arrivalRate) * (0.55 + Math.random() * 0.9);
    spawn();
  }

  assign();

  for (let i = allC.length - 1; i >= 0; i--) {
    tick(allC[i], dt);
    if (allC[i].state === 'done') allC.splice(i, 1);
  }

  // Stats
  const avgW = waitLog.length ? Math.round(waitLog.reduce((a,b)=>a+b,0)/waitLog.length) : 0;
  tputLog = tputLog.filter(t => simTime - t < 60);
  const qd = P.queueType === 'dedicated'
    ? L.regs.reduce((s,r) => s + r.laneQ.length, 0) : masterQ.length;

  document.getElementById('sWait').textContent   = avgW;
  document.getElementById('sServed').textContent = served;
  document.getElementById('sTput').textContent   = tputLog.length;
  document.getElementById('sQueue').textContent  = qd;
  document.getElementById('txtTime').textContent = `T+${Math.floor(simTime)}s`;
  
  // Update KPIs
  updateKPIs();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DRAW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderFrame() {
  const { W, H, PAD, WALL, FLOOR, regs } = L;
  ctx.clearRect(0, 0, W, H);

  // Floor
  ctx.fillStyle = '#fafbfc';
  ctx.fillRect(0, 0, W, H);
  ctx.strokeStyle = 'rgba(226,232,240,0.6)'; ctx.lineWidth = 1;
  for (let x = 0; x <= W; x += 30) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for (let y = 0; y <= H; y += 30) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  // Register wall
  ctx.fillStyle = '#f1f5f9';
  ctx.fillRect(0, 0, W, WALL);
  const wg = ctx.createLinearGradient(0, WALL, 0, WALL+20);
  wg.addColorStop(0,'rgba(0,0,0,.08)'); wg.addColorStop(1,'transparent');
  ctx.fillStyle = wg; ctx.fillRect(0, WALL, W, 20);

  // Queue guides
  drawGuides();

  // Lane dividers + flow arrows from queue to registers
  for (let i = 1; i < P.numLanes; i++) {
    const dx = PAD + i * L.LW - 1;
    ctx.strokeStyle = 'rgba(226,232,240,0.8)'; ctx.lineWidth = 1;
    ctx.setLineDash([4,10]);
    ctx.beginPath(); ctx.moveTo(dx, WALL); ctx.lineTo(dx, FLOOR); ctx.stroke();
    ctx.setLineDash([]);
  }
  // Dashed flow lines: one per register, from queue line up to serve spot
  const QYf = queueY();
  L.regs.forEach(r => {
    ctx.strokeStyle = 'rgba(59,130,246,0.2)'; ctx.lineWidth = 2;
    ctx.setLineDash([4,8]);
    ctx.beginPath(); ctx.moveTo(r.cx, QYf - 12); ctx.lineTo(r.cx, r.serveY + 14); ctx.stroke();
    ctx.setLineDash([]);
  });

  // Customers (behind registers)
  allC.forEach(c => { if (c.state !== 'serving' && c.state !== 'walking') drawCust(c); });

  // Registers
  drawRegs();

  // Customers (at registers)
  allC.forEach(c => { if (c.state === 'serving' || c.state === 'walking') drawCust(c); });

  // Entrance line (customers spawn here and immediately walk to queue)
  ctx.strokeStyle = 'rgba(59,130,246,0.3)'; ctx.lineWidth = 1.5;
  ctx.setLineDash([8,7]);
  ctx.beginPath(); ctx.moveTo(PAD, FLOOR); ctx.lineTo(W-PAD, FLOOR); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(59,130,246,0.6)'; ctx.font = '9px Space Mono'; ctx.textAlign = 'center';
  ctx.fillText('â–²  CUSTOMERS ARRIVE HERE  â–²', W/2, FLOOR+14);

  // Queue count badge â€” shown just above the queue line
  const QY = queueY();
  if (P.queueType === 'dedicated') {
    regs.forEach(r => {
      if (r.laneQ.length > 0) badge(r.cx, QY - 22, r.laneQ.length);
    });
  } else if (masterQ.length > 0) {
    badge(L.W/2 + 60, QY - 22, masterQ.length);
  }
}

function drawGuides() {
  const { W, PAD, WALL, FLOOR } = L;
  const QY    = queueY();           // y of the queue line
  const ZONE  = FLOOR - 22;         // bottom of waiting zone
  const ZTOP  = QY - 16;            // top of waiting zone highlight

  if (P.queueType === 'snake' && SNAKE.length > 1) {
    // Snake rope path drawn in bottom zone
    ctx.strokeStyle = 'rgba(16,185,129,0.15)';
    ctx.lineWidth = 16; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath(); ctx.moveTo(SNAKE[0].x, SNAKE[0].y);
    SNAKE.forEach(s => ctx.lineTo(s.x, s.y)); ctx.stroke();
    ctx.strokeStyle = 'rgba(16,185,129,0.3)';
    ctx.lineWidth = 1.5; ctx.setLineDash([6,6]); ctx.stroke(); ctx.setLineDash([]);

  } else if (P.queueType === 'single') {
    // Horizontal band at bottom = the waiting zone
    ctx.fillStyle = 'rgba(59,130,246,0.05)';
    ctx.fillRect(PAD*2, ZTOP, W - PAD*4, 32);
    // Horizontal dashed line = the queue line itself
    ctx.strokeStyle = 'rgba(59,130,246,0.4)';
    ctx.lineWidth = 1; ctx.setLineDash([6, 8]);
    ctx.beginPath(); ctx.moveTo(PAD*2, QY); ctx.lineTo(W - PAD*2, QY); ctx.stroke();
    ctx.setLineDash([]);
    // Left cap (front of line marker)
    ctx.fillStyle = 'rgba(59,130,246,0.7)';
    ctx.font = '8px Space Mono'; ctx.textAlign = 'left';
    ctx.fillText('FRONT', PAD*2, QY - 6);
    ctx.fillStyle = 'rgba(59,130,246,0.5)';
    ctx.textAlign = 'right';
    ctx.fillText('BACK', W - PAD*2, QY - 6);

  } else if (P.queueType === 'dedicated') {
    // One horizontal band per lane at the bottom
    L.regs.forEach(r => {
      ctx.fillStyle = 'rgba(59,130,246,0.04)';
      ctx.fillRect(r.cx - L.LW/2 + 4, ZTOP, L.LW - 8, 32);
      ctx.strokeStyle = 'rgba(59,130,246,0.3)';
      ctx.lineWidth = 1; ctx.setLineDash([4,7]);
      ctx.beginPath(); ctx.moveTo(r.cx - L.LW/2 + 6, QY); ctx.lineTo(r.cx + L.LW/2 - 6, QY); ctx.stroke();
      ctx.setLineDash([]);
      // Dashed line from queue up to register
      ctx.strokeStyle = 'rgba(59,130,246,0.15)';
      ctx.lineWidth = 1; ctx.setLineDash([3,8]);
      ctx.beginPath(); ctx.moveTo(r.cx, r.serveY + 10); ctx.lineTo(r.cx, QY); ctx.stroke();
      ctx.setLineDash([]);
    });
  }
}

function drawRegs() {
  L.regs.forEach(r => {
    const { rx, ry, rw, rh, cx, id, busy, serving } = r;

    ctx.shadowColor = busy ? '#ef4444' : '#3b82f6';
    ctx.shadowBlur  = busy ? 18 : 10;
    ctx.fillStyle   = busy ? '#fef2f2' : '#eff6ff';
    ctx.fillRect(rx, ry, rw, rh);
    ctx.strokeStyle = busy ? '#ef4444' : '#3b82f6';
    ctx.lineWidth   = busy ? 2 : 1.5;
    ctx.strokeRect(rx+1, ry+1, rw-2, rh-2);
    ctx.shadowBlur = 0;

    // Belt
    const bY = ry + rh - 13;
    ctx.strokeStyle = busy ? 'rgba(239,68,68,0.4)' : 'rgba(59,130,246,0.3)';
    ctx.lineWidth = 1.5; ctx.lineCap = 'round';
    for (let bx = rx+8; bx < rx+rw-8; bx += 12) {
      ctx.beginPath(); ctx.moveTo(bx,bY); ctx.lineTo(bx+6,bY); ctx.stroke();
    }

    // Monitor
    ctx.fillStyle = busy ? 'rgba(239,68,68,0.15)' : 'rgba(59,130,246,0.12)';
    ctx.fillRect(cx-10, ry+5, 20, 14);
    ctx.strokeStyle = busy ? '#ef4444' : '#3b82f6'; ctx.lineWidth = 1;
    ctx.strokeRect(cx-10, ry+5, 20, 14);

    // Cashier
    ctx.beginPath(); ctx.arc(cx, ry+5, 4, 0, Math.PI*2);
    ctx.fillStyle = busy ? 'rgba(239,68,68,0.4)' : 'rgba(59,130,246,0.3)'; ctx.fill();

    // Labels
    ctx.fillStyle = busy ? '#ef4444' : '#3b82f6';
    ctx.font = 'bold 10px Space Mono,monospace'; ctx.textAlign = 'center';
    ctx.fillText(`L${id+1}`, cx, ry+rh-17);
    ctx.font = '8px Space Mono,monospace';
    ctx.fillStyle = busy ? '#ef4444' : '#10b981';
    ctx.fillText(busy ? 'â— BUSY' : 'â— OPEN', cx, ry+rh-5);

    // Lane time label
    const t = laneTime[id] !== undefined ? laneTime[id] : 30;
    ctx.fillStyle = 'rgba(15,23,42,0.4)';
    ctx.font = '7px Space Mono,monospace';
    ctx.fillText(`${t}s/cust`, cx, ry+rh-27);

    // Progress bar
    if (busy && serving) {
      const p = serving.svcProg / serving.svcTotal;
      ctx.fillStyle = 'rgba(239,68,68,0.15)'; ctx.fillRect(rx+4, ry+rh-2, rw-8, 3);
      ctx.fillStyle = '#ef4444'; ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 4;
      ctx.fillRect(rx+4, ry+rh-2, (rw-8)*p, 3); ctx.shadowBlur = 0;
    }
  });
}

function drawCust(c) {
  ctx.save();
  ctx.globalAlpha = Math.max(0, c.opacity);
  
  // Color based on state
  const col =
    c.state === 'serving'  ? '#ef4444' :
    c.state === 'walking'  ? '#f59e0b' :
    c.state === 'leaving'  ? '#8b5cf6' :
    c.state === 'queuing'  ? '#10b981' : '#3b82f6';
  
  // Scale based on basket size (bigger basket = slightly bigger person)
  const scale = 1 + Math.min(c.basket / 100, 0.3);
  
  ctx.translate(c.x, c.y);
  ctx.scale(scale, scale);
  
  // Subtle glow
  ctx.shadowColor = col;
  ctx.shadowBlur = 8;
  
  // Head (circle)
  ctx.fillStyle = col;
  ctx.beginPath();
  ctx.arc(0, -12, 6, 0, Math.PI * 2);
  ctx.fill();
  
  // Body (rounded rectangle)
  ctx.beginPath();
  ctx.moveTo(-5, -4 + 4);
  ctx.lineTo(-5, 12 - 4);
  ctx.quadraticCurveTo(-5, 12, -5 + 4, 12);
  ctx.lineTo(5 - 4, 12);
  ctx.quadraticCurveTo(5, 12, 5, 12 - 4);
  ctx.lineTo(5, -4 + 4);
  ctx.quadraticCurveTo(5, -4, 5 - 4, -4);
  ctx.lineTo(-5 + 4, -4);
  ctx.quadraticCurveTo(-5, -4, -5, -4 + 4);
  ctx.fill();
  
  ctx.shadowBlur = 0;
  
  // Service progress arc (when being served)
  if (c.state === 'serving' && c.svcTotal > 0) {
    const p = c.svcProg / c.svcTotal;
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 2.5;
    ctx.shadowColor = '#ef4444';
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(0, 0, 18, -Math.PI / 2, -Math.PI / 2 + p * Math.PI * 2);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
  
  // Basket size indicator (small dots under feet for items)
  if (c.basket > 15 && c.state !== 'leaving') {
    ctx.fillStyle = col + '60';
    const dots = Math.min(Math.floor(c.basket / 10), 4);
    for (let i = 0; i < dots; i++) {
      ctx.beginPath();
      ctx.arc(-6 + i * 4, 16, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  ctx.restore();
}

function badge(x, y, n) {
  ctx.save(); ctx.fillStyle = '#10b981';
  ctx.shadowColor = '#10b981'; ctx.shadowBlur = 8;
  ctx.font = 'bold 10px Space Mono,monospace'; ctx.textAlign = 'center';
  ctx.fillText(`${n} in queue`, x, y); ctx.shadowBlur = 0; ctx.restore();
}

function log(type, msg) {
  const body = document.getElementById('logBody');
  const d = document.createElement('div');
  d.className = `le ${type}`;
  d.innerHTML = `<span class="ts">T+${Math.floor(simTime)}s</span><span class="ev">${msg}</span>`;
  body.insertBefore(d, body.firstChild);
  while (body.children.length > 80) body.removeChild(body.lastChild);
  logN++;
  document.getElementById('logCount').textContent = `${logN} events`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loop(ts) {
  if (!running) return;
  const dt = Math.min((ts - lastTs) / 1000, 0.05);
  lastTs = ts;
  step(dt);
  renderFrame();
  rafId = requestAnimationFrame(loop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startStop() {
  if (running) {
    running = false; cancelAnimationFrame(rafId);
    document.getElementById('btnRun').textContent = 'â–¶ RESUME';
    document.getElementById('dotStatus').className = 'dot stop';
    document.getElementById('txtStatus').textContent = 'Paused';
  } else {
    running = true; lastTs = performance.now();
    document.getElementById('btnRun').textContent = 'â¸ PAUSE';
    document.getElementById('dotStatus').className = 'dot run';
    document.getElementById('txtStatus').textContent = 'Running';
    rafId = requestAnimationFrame(loop);
  }
}

function reset() {
  running = false; cancelAnimationFrame(rafId);
  allC = []; masterQ = [];
  nextId = 0; nextArrival = 0; simTime = 0;
  served = 0; waitLog = []; tputLog = []; logN = 0;
  peakWait = 0; slaMetCount = 0;
  L.regs.forEach(r => { r.totalBusy = 0; r.busyStart = null; });
  document.getElementById('logBody').innerHTML = '';
  document.getElementById('logCount').textContent = '0 events';
  document.getElementById('btnRun').textContent = 'â–¶ START SIMULATION';
  document.getElementById('dotStatus').className = 'dot stop';
  document.getElementById('txtStatus').textContent = 'Stopped';
  document.getElementById('txtTime').textContent = 'T+0s';
  ['sWait','sServed','sTput','sQueue'].forEach(id => document.getElementById(id).textContent = '0');
  buildLayout();
  buildLaneSliders();
  renderFrame();
}

// â”€â”€ Lane speed sliders (dynamic) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildLaneSliders() {
  const container = document.getElementById('laneSliders');
  container.innerHTML = '';
  // Grow array if needed
  while (laneTime.length < P.numLanes) laneTime.push(30);

  for (let i = 0; i < P.numLanes; i++) {
    const val = laneTime[i];
    const row = document.createElement('div');
    row.className = 'lane-row';
    row.innerHTML = `
      <div class="lane-row-label">
        <span>Lane ${i+1}</span>
        <b id="lt-v-${i}">${val}s</b>
      </div>
      <input type="range" min="0" max="600" step="5" value="${val}" id="lt-${i}">
      <div class="hint"><span>0s instant</span><span>600s (10 min)</span></div>
    `;
    container.appendChild(row);
    // Wire immediately
    document.getElementById(`lt-${i}`).addEventListener('input', function() {
      laneTime[i] = +this.value;
      document.getElementById(`lt-v-${i}`).textContent = this.value + 's';
    });
  }
}

// â”€â”€ Button wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('btnRun').addEventListener('click', startStop);
document.getElementById('btnReset').addEventListener('click', reset);

// â”€â”€ Global sliders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('cLanes').addEventListener('input', function() {
  P.numLanes = +this.value;
  document.getElementById('vLanes').textContent = this.value;
  while (laneTime.length < P.numLanes) laneTime.push(30);
  reset();
});
document.getElementById('cArrival').addEventListener('input', function() {
  P.arrivalRate = +this.value;
  document.getElementById('vArrival').textContent = this.value;
});
document.getElementById('cSimSpeed').addEventListener('input', function() {
  P.simSpeed = +this.value;
  document.getElementById('vSimSpeed').textContent = this.value + 'Ã—';
});

// â”€â”€ Toggle buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.querySelectorAll('[data-queue]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('[data-queue]').forEach(b => b.classList.remove('on'));
    btn.classList.add('on');
    P.queueType = btn.dataset.queue;
    reset();
  });
});
document.querySelectorAll('[data-mix]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('[data-mix]').forEach(b => b.classList.remove('on'));
    btn.classList.add('on');
    P.custMix = btn.dataset.mix;
  });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
buildLayout();
buildLaneSliders();
renderFrame();
</script>
</body>
</html>
