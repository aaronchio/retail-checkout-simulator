<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Checkout Flow Simulator</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;700;800&display=swap');
:root {
  --bg:#0a0e1a;--panel:#111827;--border:#1e2d45;
  --accent:#00e5ff;--accent2:#ff6b35;--accent3:#a8ff3e;
  --text:#e2e8f0;--dim:#64748b;--lane:#0d1929;
}
*{box-sizing:border-box;margin:0;padding:0;}
body{background:var(--bg);color:var(--text);font-family:'Space Mono',monospace;min-height:100vh;overflow-x:hidden;}
body::before{content:'';position:fixed;inset:0;background-image:linear-gradient(rgba(0,229,255,.03) 1px,transparent 1px),linear-gradient(90deg,rgba(0,229,255,.03) 1px,transparent 1px);background-size:40px 40px;pointer-events:none;z-index:0;}
.app{position:relative;z-index:1;max-width:1400px;margin:0 auto;padding:20px;}
header{display:flex;align-items:center;justify-content:space-between;padding:16px 0 24px;border-bottom:1px solid var(--border);margin-bottom:24px;}
.logo{font-family:'Syne',sans-serif;font-weight:800;font-size:1.6rem;letter-spacing:-.02em;}
.logo span{color:var(--accent);}
.badge{font-size:.65rem;background:var(--accent);color:var(--bg);padding:3px 8px;border-radius:2px;font-weight:700;letter-spacing:.1em;margin-left:10px;vertical-align:middle;}
.layout{display:grid;grid-template-columns:290px 1fr;gap:20px;align-items:start;}

/* Controls */
.controls{background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:18px;position:sticky;top:20px;max-height:95vh;overflow-y:auto;}
.controls::-webkit-scrollbar{width:3px;}
.controls::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px;}
.controls h2{font-family:'Syne',sans-serif;font-size:.72rem;letter-spacing:.15em;text-transform:uppercase;color:var(--accent);margin-bottom:16px;padding-bottom:10px;border-bottom:1px solid var(--border);}
.cg{margin-bottom:16px;}
.cg label{display:flex;justify-content:space-between;font-size:.68rem;color:var(--dim);margin-bottom:7px;letter-spacing:.05em;text-transform:uppercase;}
.cg label span{color:var(--accent);font-weight:700;}
.cg .hint{display:flex;justify-content:space-between;font-size:.56rem;color:#374151;margin-top:3px;}
input[type=range]{-webkit-appearance:none;width:100%;height:4px;background:var(--border);border-radius:2px;outline:none;}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;background:var(--accent);border-radius:50%;cursor:pointer;box-shadow:0 0 8px var(--accent);}
.tg{display:flex;gap:6px;flex-wrap:wrap;}
.tb{flex:1;min-width:70px;padding:7px 8px;background:var(--lane);border:1px solid var(--border);color:var(--dim);font-family:'Space Mono',monospace;font-size:.62rem;cursor:pointer;border-radius:4px;transition:all .2s;text-align:center;letter-spacing:.04em;}
.tb.on{background:rgba(0,229,255,.1);border-color:var(--accent);color:var(--accent);box-shadow:0 0 10px rgba(0,229,255,.15);}
.sep{border:none;border-top:1px solid var(--border);margin:14px 0;}

/* Lane speed rows */
.lane-row{margin-bottom:12px;}
.lane-row-label{display:flex;justify-content:space-between;font-size:.65rem;color:var(--dim);margin-bottom:5px;text-transform:uppercase;letter-spacing:.05em;}
.lane-row-label b{color:var(--accent);font-weight:700;}

/* Buttons */
.btn-primary{width:100%;padding:12px;margin-top:6px;background:var(--accent);color:var(--bg);border:none;font-family:'Syne',sans-serif;font-size:.88rem;font-weight:700;letter-spacing:.08em;cursor:pointer;border-radius:4px;transition:all .2s;text-transform:uppercase;}
.btn-primary:hover{background:#33eaff;box-shadow:0 0 20px rgba(0,229,255,.4);}
.btn-secondary{width:100%;padding:9px;margin-top:6px;background:transparent;color:var(--dim);border:1px solid var(--border);font-family:'Space Mono',monospace;font-size:.68rem;cursor:pointer;border-radius:4px;transition:all .2s;letter-spacing:.05em;}
.btn-secondary:hover{border-color:var(--accent2);color:var(--accent2);}

/* Stats */
.stats{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-bottom:16px;}
.sc{background:var(--panel);border:1px solid var(--border);border-radius:6px;padding:12px 14px;position:relative;overflow:hidden;}
.sc::before{content:'';position:absolute;top:0;left:0;right:0;height:2px;}
.sc:nth-child(1)::before{background:var(--accent);}
.sc:nth-child(2)::before{background:var(--accent2);}
.sc:nth-child(3)::before{background:var(--accent3);}
.sc:nth-child(4)::before{background:#c084fc;}
.sl{font-size:.6rem;text-transform:uppercase;letter-spacing:.1em;color:var(--dim);margin-bottom:5px;}
.sv{font-family:'Syne',sans-serif;font-size:1.7rem;font-weight:800;line-height:1;}
.sc:nth-child(1) .sv{color:var(--accent);}
.sc:nth-child(2) .sv{color:var(--accent2);}
.sc:nth-child(3) .sv{color:var(--accent3);}
.sc:nth-child(4) .sv{color:#c084fc;}
.su{font-size:.6rem;color:var(--dim);margin-top:2px;}

/* Canvas */
.simbox{background:var(--panel);border:1px solid var(--border);border-radius:8px;overflow:hidden;}
.simhdr{display:flex;align-items:center;justify-content:space-between;padding:11px 16px;border-bottom:1px solid var(--border);background:var(--lane);}
.simtitle{font-family:'Syne',sans-serif;font-size:.72rem;letter-spacing:.1em;text-transform:uppercase;color:var(--dim);}
.simstatus{display:flex;align-items:center;gap:8px;font-size:.62rem;color:var(--dim);}
.dot{width:7px;height:7px;border-radius:50%;background:var(--dim);display:inline-block;}
.dot.run{background:var(--accent3);box-shadow:0 0 6px var(--accent3);animation:pulse 1s infinite;}
.dot.stop{background:var(--accent2);}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.4}}
canvas{display:block;width:100%;}
.speedrow{display:flex;align-items:center;gap:14px;padding:9px 16px;border-top:1px solid var(--border);background:var(--lane);}
.speedlbl{font-size:.62rem;text-transform:uppercase;letter-spacing:.1em;color:var(--dim);white-space:nowrap;}
.speedrow input{flex:1;}

/* Legend */
.legend{display:flex;gap:14px;flex-wrap:wrap;padding:10px 16px;border:1px solid var(--border);border-radius:6px;margin-top:10px;font-size:.6rem;color:var(--dim);background:var(--panel);}
.li{display:flex;align-items:center;gap:6px;}
.ld{width:9px;height:9px;border-radius:50%;flex-shrink:0;}

/* Log */
.log{background:var(--panel);border:1px solid var(--border);border-radius:8px;margin-top:12px;overflow:hidden;}
.loghdr{padding:9px 16px;border-bottom:1px solid var(--border);font-size:.62rem;text-transform:uppercase;letter-spacing:.1em;color:var(--dim);background:var(--lane);display:flex;justify-content:space-between;}
.logbody{height:90px;overflow-y:auto;padding:6px 16px;font-size:.62rem;line-height:1.9;}
.logbody::-webkit-scrollbar{width:3px;}
.logbody::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px;}
.le .ts{color:#00e5ff;margin-right:8px;}
.le.join .ev{color:#a8ff3e;}
.le.done .ev{color:#ff6b35;}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="logo">CHECKOUT<span>SIM</span><span class="badge">V3</span></div>
    <div style="font-size:.62rem;color:var(--dim);letter-spacing:.1em;">RETAIL QUEUE SIMULATOR</div>
  </header>

  <div class="layout">
    <!-- ── CONTROLS ── -->
    <div class="controls">
      <h2>⚙ Parameters</h2>

      <div class="cg">
        <label>Checkout Lanes <span id="vLanes">4</span></label>
        <input type="range" id="cLanes" min="1" max="10" value="4">
      </div>

      <div class="cg">
        <label>Customers Arriving <span id="vArrival">6</span>/min</label>
        <input type="range" id="cArrival" min="1" max="60" value="6">
        <div class="hint"><span>1 (quiet)</span><span>60 (rush hour)</span></div>
      </div>

      <hr class="sep">

      <div class="cg">
        <label style="margin-bottom:9px;display:block;color:var(--accent);">Lane Service Time (seconds)</label>
        <div style="font-size:.6rem;color:var(--dim);margin-bottom:10px;">How many seconds to fully serve one customer per lane. 0 = instant, 600 = 10 min.</div>
        <div id="laneSliders"></div>
      </div>

      <hr class="sep">

      <div class="cg">
        <label style="margin-bottom:9px;">Queue Layout</label>
        <div class="tg">
          <button class="tb on" data-queue="single">Single Feed</button>
          <button class="tb" data-queue="snake">Snake</button>
          <button class="tb" data-queue="dedicated">Per Lane</button>
        </div>
      </div>

      <div class="cg">
        <label style="margin-bottom:9px;">Customer Mix</label>
        <div class="tg">
          <button class="tb on" data-mix="normal">Normal</button>
          <button class="tb" data-mix="slow">Slow</button>
          <button class="tb" data-mix="express">Express</button>
        </div>
      </div>

      <button class="btn-primary" id="btnRun">▶ START SIMULATION</button>
      <button class="btn-secondary" id="btnReset">↺ Reset</button>
    </div>

    <!-- ── MAIN AREA ── -->
    <div>
      <div class="stats">
        <div class="sc"><div class="sl">Avg Wait</div><div class="sv" id="sWait">0</div><div class="su">seconds</div></div>
        <div class="sc"><div class="sl">Served</div><div class="sv" id="sServed">0</div><div class="su">customers</div></div>
        <div class="sc"><div class="sl">Throughput</div><div class="sv" id="sTput">0</div><div class="su">per minute</div></div>
        <div class="sc"><div class="sl">Queuing</div><div class="sv" id="sQueue">0</div><div class="su">waiting</div></div>
      </div>

      <div class="simbox">
        <div class="simhdr">
          <div class="simtitle">Live Store Floor</div>
          <div class="simstatus">
            <div class="dot stop" id="dotStatus"></div>
            <span id="txtStatus">Stopped</span>
            <span style="margin-left:12px;color:var(--accent);" id="txtTime">T+0s</span>
          </div>
        </div>
        <canvas id="simCanvas" height="500"></canvas>
        <div class="speedrow">
          <span class="speedlbl">Sim Speed</span>
          <input type="range" id="cSimSpeed" min="0.5" max="6" step="0.5" value="1">
          <span style="font-size:.62rem;color:var(--accent);min-width:28px;" id="vSimSpeed">1×</span>
        </div>
      </div>

      <div class="legend">
        <div class="li"><div class="ld" style="background:#00e5ff;"></div>Entering</div>
        <div class="li"><div class="ld" style="background:#a8ff3e;"></div>Waiting in line</div>
        <div class="li"><div class="ld" style="background:#fbbf24;"></div>Walking to register</div>
        <div class="li"><div class="ld" style="background:#ff6b35;"></div>Being served</div>
        <div class="li"><div class="ld" style="background:#c084fc;"></div>Leaving</div>
        <div class="li"><span style="color:var(--dim);">Ring size = basket size</span></div>
      </div>

      <div class="log">
        <div class="loghdr"><span>Event Log</span><span id="logCount" style="color:var(--accent);">0 events</span></div>
        <div class="logbody" id="logBody"></div>
      </div>
    </div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════
//  CANVAS
// ═══════════════════════════════════════════════
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
function resizeCanvas() { canvas.width = canvas.parentElement.clientWidth; }
resizeCanvas();
window.addEventListener('resize', () => { resizeCanvas(); buildLayout(); renderFrame(); });

// ═══════════════════════════════════════════════
//  PARAMS
// ═══════════════════════════════════════════════
const P = {
  numLanes: 4,
  arrivalRate: 6,      // customers per minute
  queueType: 'single', // 'single' | 'snake' | 'dedicated'
  custMix: 'normal',   // 'normal' | 'slow' | 'express'
  simSpeed: 1,
};

// Per-lane service time in real seconds (how long to fully serve one customer)
let laneTime = [30, 30, 30, 30];

// ═══════════════════════════════════════════════
//  LAYOUT
// ═══════════════════════════════════════════════
let L = {};
let SNAKE = [];  // snake path slots [{x,y}]
const SLOT_GAP = 18;
const PAL = ['#00e5ff','#a8ff3e','#fbbf24','#c084fc','#fb7185','#34d399','#f97316','#60a5fa'];

function buildLayout() {
  const W = canvas.width, H = canvas.height;
  const PAD = 16, RH = 54, RY = PAD + 8;
  const WALL = RY + RH + 8;
  const FLOOR = H - 30;
  const LW = Math.floor((W - PAD * 2) / P.numLanes);

  const regs = [];
  for (let i = 0; i < P.numLanes; i++) {
    const cx = PAD + i * LW + LW / 2;
    regs.push({
      id: i, cx,
      rx: PAD + i * LW + 5, ry: RY,
      rw: LW - 10, rh: RH,
      serveX: cx, serveY: WALL + 18,
      qColX: cx,
      busy: false, serving: null,
      laneQ: [],
    });
  }

  L = { W, H, PAD, RH, RY, WALL, FLOOR, LW, regs };
  buildSnake();
}

function buildSnake() {
  SNAKE = [];
  const { W, PAD, FLOOR } = L;
  // Snake only in the bottom ~40% of floor space, above entrance
  const ZONE_TOP  = FLOOR - 160;
  const ZONE_BOT  = FLOOR - 22;
  const ROW_H = 20, usW = W - PAD * 2;
  for (let row = 0; ZONE_TOP + row * ROW_H < ZONE_BOT; row++) {
    const y = ZONE_TOP + row * ROW_H + 10;
    const ltr = row % 2 === 0;
    for (let col = 0; col < 12; col++) {
      const frac = (col + 0.5) / 12;
      SNAKE.push({ x: PAD + (ltr ? frac : 1 - frac) * usW, y });
    }
  }
}

// ═══════════════════════════════════════════════
//  QUEUE TARGETS
//
//  The queue is a HORIZONTAL LINE at the bottom of
//  the canvas, just above the entrance marker.
//
//  Slot 0 = front of line (LEFT side, nearest register)
//  Slot N = back of line  (RIGHT side, new arrivals join here)
//
//  Snake mode: zigzags back-and-forth in the bottom zone.
//  Per-lane:   each lane has its own horizontal sub-row.
// ═══════════════════════════════════════════════

// Y position of the queue line (single row of people)
function queueY() { return L.FLOOR - 30; }

// X position for a slot in the master queue (single/snake)
// Slots spread LEFT → RIGHT across the full canvas width
function masterTarget(slot) {
  if (P.queueType === 'snake') {
    const s = SNAKE[Math.min(slot, SNAKE.length - 1)];
    return { x: s.x, y: s.y };
  }
  // Single feed: one horizontal line, centred, spreading outward from centre
  const QY = queueY();
  const totalW = L.W - L.PAD * 4;
  const spacing = Math.min(SLOT_GAP, totalW / Math.max(masterQ.length, 1));
  // Anchor the FRONT of the line to left-centre, grow rightward
  const startX = L.PAD * 2;
  return { x: startX + slot * spacing, y: QY };
}

// Per-lane: each lane gets its own row, stacked above each other if needed
function laneTarget(laneId, slot) {
  const QY = queueY();
  const r = L.regs[laneId];
  // Each lane's queue fans out horizontally below its register column
  const spacing = Math.min(SLOT_GAP, (L.W - L.PAD*2) / Math.max(r.laneQ.length, 1));
  const startX = r.cx - (r.laneQ.length * spacing) / 2;
  return { x: startX + slot * spacing, y: QY - laneId * 4 };
}

// ═══════════════════════════════════════════════
//  SIM STATE
// ═══════════════════════════════════════════════
let running = false, rafId = null, lastTs = 0;
let simTime = 0, served = 0;
let waitLog = [], tputLog = [];
let masterQ = [];
let allC = [];
let nextId = 0, nextArrival = 0, logN = 0;

// ═══════════════════════════════════════════════
//  CUSTOMER
// ═══════════════════════════════════════════════
function mkCust() {
  let sm = 0.8 + Math.random() * 0.4;
  if (P.custMix === 'slow')    sm = 0.35 + Math.random() * 0.3;
  if (P.custMix === 'express') sm = 1.5  + Math.random() * 1.0;
  return {
    id: nextId++,
    basket: 5 + Math.floor(Math.random() * 30),
    sm,
    col: PAL[nextId % PAL.length],
    x: L.PAD + Math.random() * (L.W - L.PAD * 2),
    y: L.FLOOR,
    tx: 0, ty: 0,
    // entering → queuing → walking → serving → leaving → done
    state: 'entering',
    lane: -1, slot: -1,
    svcProg: 0, svcTotal: 0,
    waitStart: 0, opacity: 1,
  };
}

// ═══════════════════════════════════════════════
//  SPAWN
// ═══════════════════════════════════════════════
function spawn() {
  const c = mkCust();
  allC.push(c);

  if (P.queueType === 'dedicated') {
    let best = 0, bestLen = Infinity;
    L.regs.forEach((r, i) => {
      const n = r.laneQ.length + (r.busy ? 1 : 0);
      if (n < bestLen) { bestLen = n; best = i; }
    });
    c.lane = best;
    L.regs[best].laneQ.push(c);
    // Recompute all slots so spacing adjusts as queue grows
    L.regs[best].laneQ.forEach((x, i) => {
      x.slot = i;
      const t = laneTarget(best, i);
      x.tx = t.x; x.ty = t.y;
    });
    c.slot = L.regs[best].laneQ.length - 1;
  } else {
    c.slot = masterQ.length;
    masterQ.push(c);
    // Recompute all slots so spacing adjusts as queue grows
    masterQ.forEach((x, i) => {
      x.slot = i;
      const t = masterTarget(i);
      x.tx = t.x; x.ty = t.y;
    });
  }

  c.waitStart = simTime;
  log('join', `#${c.id} arrived`);
}

// ═══════════════════════════════════════════════
//  ASSIGN QUEUE → REGISTER
// ═══════════════════════════════════════════════
function assign() {
  if (P.queueType === 'dedicated') {
    L.regs.forEach(r => {
      if (!r.busy && r.laneQ.length > 0) serve(r, r.laneQ[0], true);
    });
  } else {
    L.regs.forEach(r => {
      if (!r.busy && masterQ.length > 0) serve(r, masterQ[0], false);
    });
  }
}

function serve(reg, c, dedicated) {
  if (dedicated) {
    reg.laneQ.shift();
    // Recompute spacing now that queue is shorter
    reg.laneQ.forEach((x, i) => {
      x.slot = i;
      const t = laneTarget(reg.id, i);
      x.tx = t.x; x.ty = t.y;
    });
  } else {
    masterQ.shift();
    // Recompute spacing now that queue is shorter
    masterQ.forEach((x, i) => {
      x.slot = i;
      const t = masterTarget(i);
      x.tx = t.x; x.ty = t.y;
    });
  }

  reg.busy = true; reg.serving = c;
  c.state = 'walking'; c.lane = reg.id;
  c.tx = reg.serveX; c.ty = reg.serveY;

  // Service time = lane's configured seconds, scaled by customer speedMult
  const base = laneTime[reg.id] !== undefined ? laneTime[reg.id] : 30;
  c.svcTotal = base === 0 ? 0.01 : base / c.sm;
  c.svcProg = 0;

  const waited = Math.round(simTime - c.waitStart);
  waitLog.push(waited);
  if (waitLog.length > 300) waitLog.shift();
  tputLog.push(simTime);
  log('done', `Lane ${reg.id+1} → #${c.id} (waited ${waited}s)`);
}

// ═══════════════════════════════════════════════
//  UPDATE CUSTOMER
// ═══════════════════════════════════════════════
const WALK = 95;

function tick(c, dt) {
  const dx = c.tx - c.x, dy = c.ty - c.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if (dist > 1) {
    const step = Math.min(WALK * dt, dist);
    c.x += dx / dist * step;
    c.y += dy / dist * step;
  } else {
    c.x = c.tx; c.y = c.ty;
    if (c.state === 'entering') c.state = 'queuing';
    if (c.state === 'walking')  c.state = 'serving';
  }

  if (c.state === 'serving') {
    c.svcProg += dt;
    if (c.svcProg >= c.svcTotal) finish(c);
  }

  if (c.state === 'leaving') {
    const d = Math.sqrt((c.tx-c.x)**2 + (c.ty-c.y)**2);
    if (d < 50) { c.opacity -= dt * 2; if (c.opacity <= 0) c.state = 'done'; }
  }
}

function finish(c) {
  const r = L.regs[c.lane];
  r.busy = false; r.serving = null;
  c.state = 'leaving';
  c.tx = r.cx + (Math.random() - 0.5) * 80;
  c.ty = L.FLOOR + 40;
  served++;
  log('done', `#${c.id} done ✓`);
}

// ═══════════════════════════════════════════════
//  SIM STEP
// ═══════════════════════════════════════════════
function step(dtReal) {
  const dt = dtReal * P.simSpeed;
  simTime += dt;

  nextArrival -= dt;
  if (nextArrival <= 0) {
    nextArrival = (60 / P.arrivalRate) * (0.55 + Math.random() * 0.9);
    spawn();
  }

  assign();

  for (let i = allC.length - 1; i >= 0; i--) {
    tick(allC[i], dt);
    if (allC[i].state === 'done') allC.splice(i, 1);
  }

  // Stats
  const avgW = waitLog.length ? Math.round(waitLog.reduce((a,b)=>a+b,0)/waitLog.length) : 0;
  tputLog = tputLog.filter(t => simTime - t < 60);
  const qd = P.queueType === 'dedicated'
    ? L.regs.reduce((s,r) => s + r.laneQ.length, 0) : masterQ.length;

  document.getElementById('sWait').textContent   = avgW;
  document.getElementById('sServed').textContent = served;
  document.getElementById('sTput').textContent   = tputLog.length;
  document.getElementById('sQueue').textContent  = qd;
  document.getElementById('txtTime').textContent = `T+${Math.floor(simTime)}s`;
}

// ═══════════════════════════════════════════════
//  DRAW
// ═══════════════════════════════════════════════
function renderFrame() {
  const { W, H, PAD, WALL, FLOOR, regs } = L;
  ctx.clearRect(0, 0, W, H);

  // Floor
  ctx.fillStyle = '#07090f';
  ctx.fillRect(0, 0, W, H);
  ctx.strokeStyle = 'rgba(15,28,52,.9)'; ctx.lineWidth = 1;
  for (let x = 0; x <= W; x += 30) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for (let y = 0; y <= H; y += 30) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  // Register wall
  ctx.fillStyle = '#0c1520';
  ctx.fillRect(0, 0, W, WALL);
  const wg = ctx.createLinearGradient(0, WALL, 0, WALL+20);
  wg.addColorStop(0,'rgba(0,0,0,.5)'); wg.addColorStop(1,'transparent');
  ctx.fillStyle = wg; ctx.fillRect(0, WALL, W, 20);

  // Queue guides
  drawGuides();

  // Lane dividers + flow arrows from queue to registers
  for (let i = 1; i < P.numLanes; i++) {
    const dx = PAD + i * L.LW - 1;
    ctx.strokeStyle = 'rgba(30,45,69,.5)'; ctx.lineWidth = 1;
    ctx.setLineDash([4,10]);
    ctx.beginPath(); ctx.moveTo(dx, WALL); ctx.lineTo(dx, FLOOR); ctx.stroke();
    ctx.setLineDash([]);
  }
  // Dashed flow lines: one per register, from queue line up to serve spot
  const QYf = queueY();
  L.regs.forEach(r => {
    ctx.strokeStyle = 'rgba(0,229,255,.07)'; ctx.lineWidth = 2;
    ctx.setLineDash([4,8]);
    ctx.beginPath(); ctx.moveTo(r.cx, QYf - 12); ctx.lineTo(r.cx, r.serveY + 14); ctx.stroke();
    ctx.setLineDash([]);
  });

  // Customers (behind registers)
  allC.forEach(c => { if (c.state !== 'serving' && c.state !== 'walking') drawCust(c); });

  // Registers
  drawRegs();

  // Customers (at registers)
  allC.forEach(c => { if (c.state === 'serving' || c.state === 'walking') drawCust(c); });

  // Entrance line (customers spawn here and immediately walk to queue)
  ctx.strokeStyle = 'rgba(0,229,255,.2)'; ctx.lineWidth = 1.5;
  ctx.setLineDash([8,7]);
  ctx.beginPath(); ctx.moveTo(PAD, FLOOR); ctx.lineTo(W-PAD, FLOOR); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(0,229,255,.35)'; ctx.font = '9px Space Mono'; ctx.textAlign = 'center';
  ctx.fillText('▲  CUSTOMERS ARRIVE HERE  ▲', W/2, FLOOR+14);

  // Queue count badge — shown just above the queue line
  const QY = queueY();
  if (P.queueType === 'dedicated') {
    regs.forEach(r => {
      if (r.laneQ.length > 0) badge(r.cx, QY - 22, r.laneQ.length);
    });
  } else if (masterQ.length > 0) {
    badge(L.W/2 + 60, QY - 22, masterQ.length);
  }
}

function drawGuides() {
  const { W, PAD, WALL, FLOOR } = L;
  const QY    = queueY();           // y of the queue line
  const ZONE  = FLOOR - 22;         // bottom of waiting zone
  const ZTOP  = QY - 16;            // top of waiting zone highlight

  if (P.queueType === 'snake' && SNAKE.length > 1) {
    // Snake rope path drawn in bottom zone
    ctx.strokeStyle = 'rgba(168,255,62,.07)';
    ctx.lineWidth = 16; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath(); ctx.moveTo(SNAKE[0].x, SNAKE[0].y);
    SNAKE.forEach(s => ctx.lineTo(s.x, s.y)); ctx.stroke();
    ctx.strokeStyle = 'rgba(168,255,62,.2)';
    ctx.lineWidth = 1.5; ctx.setLineDash([6,6]); ctx.stroke(); ctx.setLineDash([]);

  } else if (P.queueType === 'single') {
    // Horizontal band at bottom = the waiting zone
    ctx.fillStyle = 'rgba(0,229,255,.03)';
    ctx.fillRect(PAD*2, ZTOP, W - PAD*4, 32);
    // Horizontal dashed line = the queue line itself
    ctx.strokeStyle = 'rgba(0,229,255,.25)';
    ctx.lineWidth = 1; ctx.setLineDash([6, 8]);
    ctx.beginPath(); ctx.moveTo(PAD*2, QY); ctx.lineTo(W - PAD*2, QY); ctx.stroke();
    ctx.setLineDash([]);
    // Left cap (front of line marker)
    ctx.fillStyle = 'rgba(0,229,255,.5)';
    ctx.font = '8px Space Mono'; ctx.textAlign = 'left';
    ctx.fillText('FRONT', PAD*2, QY - 6);
    ctx.fillStyle = 'rgba(0,229,255,.3)';
    ctx.textAlign = 'right';
    ctx.fillText('BACK', W - PAD*2, QY - 6);

  } else if (P.queueType === 'dedicated') {
    // One horizontal band per lane at the bottom
    L.regs.forEach(r => {
      ctx.fillStyle = 'rgba(0,229,255,.025)';
      ctx.fillRect(r.cx - L.LW/2 + 4, ZTOP, L.LW - 8, 32);
      ctx.strokeStyle = 'rgba(0,229,255,.15)';
      ctx.lineWidth = 1; ctx.setLineDash([4,7]);
      ctx.beginPath(); ctx.moveTo(r.cx - L.LW/2 + 6, QY); ctx.lineTo(r.cx + L.LW/2 - 6, QY); ctx.stroke();
      ctx.setLineDash([]);
      // Dashed line from queue up to register
      ctx.strokeStyle = 'rgba(0,229,255,.08)';
      ctx.lineWidth = 1; ctx.setLineDash([3,8]);
      ctx.beginPath(); ctx.moveTo(r.cx, r.serveY + 10); ctx.lineTo(r.cx, QY); ctx.stroke();
      ctx.setLineDash([]);
    });
  }
}

function drawRegs() {
  L.regs.forEach(r => {
    const { rx, ry, rw, rh, cx, id, busy, serving } = r;

    ctx.shadowColor = busy ? '#ff6b35' : '#00e5ff';
    ctx.shadowBlur  = busy ? 18 : 10;
    ctx.fillStyle   = busy ? '#160b04' : '#0a1520';
    ctx.fillRect(rx, ry, rw, rh);
    ctx.strokeStyle = busy ? '#ff6b35' : '#00e5ff';
    ctx.lineWidth   = busy ? 2 : 1.5;
    ctx.strokeRect(rx+1, ry+1, rw-2, rh-2);
    ctx.shadowBlur = 0;

    // Belt
    const bY = ry + rh - 13;
    ctx.strokeStyle = busy ? 'rgba(255,107,53,.4)' : 'rgba(0,229,255,.22)';
    ctx.lineWidth = 1.5; ctx.lineCap = 'round';
    for (let bx = rx+8; bx < rx+rw-8; bx += 12) {
      ctx.beginPath(); ctx.moveTo(bx,bY); ctx.lineTo(bx+6,bY); ctx.stroke();
    }

    // Monitor
    ctx.fillStyle = busy ? 'rgba(255,107,53,.25)' : 'rgba(0,229,255,.18)';
    ctx.fillRect(cx-10, ry+5, 20, 14);
    ctx.strokeStyle = busy ? '#ff6b35' : '#00e5ff'; ctx.lineWidth = 1;
    ctx.strokeRect(cx-10, ry+5, 20, 14);

    // Cashier
    ctx.beginPath(); ctx.arc(cx, ry+5, 4, 0, Math.PI*2);
    ctx.fillStyle = busy ? 'rgba(255,107,53,.5)' : 'rgba(0,229,255,.35)'; ctx.fill();

    // Labels
    ctx.fillStyle = busy ? '#ff6b35' : 'rgba(0,229,255,.8)';
    ctx.font = 'bold 10px Space Mono,monospace'; ctx.textAlign = 'center';
    ctx.fillText(`L${id+1}`, cx, ry+rh-17);
    ctx.font = '8px Space Mono,monospace';
    ctx.fillStyle = busy ? '#ff6b35' : '#a8ff3e';
    ctx.fillText(busy ? '● BUSY' : '● OPEN', cx, ry+rh-5);

    // Lane time label
    const t = laneTime[id] !== undefined ? laneTime[id] : 30;
    ctx.fillStyle = 'rgba(255,255,255,.2)';
    ctx.font = '7px Space Mono,monospace';
    ctx.fillText(`${t}s/cust`, cx, ry+rh-27);

    // Progress bar
    if (busy && serving) {
      const p = serving.svcProg / serving.svcTotal;
      ctx.fillStyle = 'rgba(255,107,53,.15)'; ctx.fillRect(rx+4, ry+rh-2, rw-8, 3);
      ctx.fillStyle = '#ff6b35'; ctx.shadowColor = '#ff6b35'; ctx.shadowBlur = 4;
      ctx.fillRect(rx+4, ry+rh-2, (rw-8)*p, 3); ctx.shadowBlur = 0;
    }
  });
}

function drawCust(c) {
  ctx.save(); ctx.globalAlpha = Math.max(0, c.opacity);
  const col =
    c.state === 'serving'  ? '#ff6b35' :
    c.state === 'walking'  ? '#fbbf24' :
    c.state === 'leaving'  ? '#c084fc' :
    c.state === 'queuing'  ? '#a8ff3e' : '#00e5ff';
  const R = 7;
  ctx.shadowColor = col; ctx.shadowBlur = 12;
  ctx.beginPath(); ctx.arc(c.x, c.y, R, 0, Math.PI*2);
  ctx.fillStyle = col; ctx.fill();
  ctx.shadowBlur = 0;
  ctx.beginPath(); ctx.arc(c.x, c.y, R*.4, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,.6)'; ctx.fill();
  const rr = R + 2 + Math.min(c.basket/14, 5);
  ctx.beginPath(); ctx.arc(c.x, c.y, rr, 0, Math.PI*2);
  ctx.strokeStyle = col+'40'; ctx.lineWidth = 1.5; ctx.stroke();
  if (c.state === 'serving' && c.svcTotal > 0) {
    const p = c.svcProg / c.svcTotal;
    ctx.beginPath(); ctx.arc(c.x, c.y, R+6, -Math.PI/2, -Math.PI/2 + p*Math.PI*2);
    ctx.strokeStyle = '#ff6b35'; ctx.lineWidth = 2.5;
    ctx.shadowColor = '#ff6b35'; ctx.shadowBlur = 6; ctx.stroke(); ctx.shadowBlur = 0;
  }
  ctx.restore();
}

function badge(x, y, n) {
  ctx.save(); ctx.fillStyle = '#a8ff3e';
  ctx.shadowColor = '#a8ff3e'; ctx.shadowBlur = 8;
  ctx.font = 'bold 10px Space Mono,monospace'; ctx.textAlign = 'center';
  ctx.fillText(`${n} in queue`, x, y); ctx.shadowBlur = 0; ctx.restore();
}

function log(type, msg) {
  const body = document.getElementById('logBody');
  const d = document.createElement('div');
  d.className = `le ${type}`;
  d.innerHTML = `<span class="ts">T+${Math.floor(simTime)}s</span><span class="ev">${msg}</span>`;
  body.insertBefore(d, body.firstChild);
  while (body.children.length > 80) body.removeChild(body.lastChild);
  logN++;
  document.getElementById('logCount').textContent = `${logN} events`;
}

// ═══════════════════════════════════════════════
//  LOOP
// ═══════════════════════════════════════════════
function loop(ts) {
  if (!running) return;
  const dt = Math.min((ts - lastTs) / 1000, 0.05);
  lastTs = ts;
  step(dt);
  renderFrame();
  rafId = requestAnimationFrame(loop);
}

// ═══════════════════════════════════════════════
//  CONTROLS
// ═══════════════════════════════════════════════
function startStop() {
  if (running) {
    running = false; cancelAnimationFrame(rafId);
    document.getElementById('btnRun').textContent = '▶ RESUME';
    document.getElementById('dotStatus').className = 'dot stop';
    document.getElementById('txtStatus').textContent = 'Paused';
  } else {
    running = true; lastTs = performance.now();
    document.getElementById('btnRun').textContent = '⏸ PAUSE';
    document.getElementById('dotStatus').className = 'dot run';
    document.getElementById('txtStatus').textContent = 'Running';
    rafId = requestAnimationFrame(loop);
  }
}

function reset() {
  running = false; cancelAnimationFrame(rafId);
  allC = []; masterQ = [];
  nextId = 0; nextArrival = 0; simTime = 0;
  served = 0; waitLog = []; tputLog = []; logN = 0;
  document.getElementById('logBody').innerHTML = '';
  document.getElementById('logCount').textContent = '0 events';
  document.getElementById('btnRun').textContent = '▶ START SIMULATION';
  document.getElementById('dotStatus').className = 'dot stop';
  document.getElementById('txtStatus').textContent = 'Stopped';
  document.getElementById('txtTime').textContent = 'T+0s';
  ['sWait','sServed','sTput','sQueue'].forEach(id => document.getElementById(id).textContent = '0');
  buildLayout();
  buildLaneSliders();
  renderFrame();
}

// ── Lane speed sliders (dynamic) ──────────────
function buildLaneSliders() {
  const container = document.getElementById('laneSliders');
  container.innerHTML = '';
  // Grow array if needed
  while (laneTime.length < P.numLanes) laneTime.push(30);

  for (let i = 0; i < P.numLanes; i++) {
    const val = laneTime[i];
    const row = document.createElement('div');
    row.className = 'lane-row';
    row.innerHTML = `
      <div class="lane-row-label">
        <span>Lane ${i+1}</span>
        <b id="lt-v-${i}">${val}s</b>
      </div>
      <input type="range" min="0" max="600" step="5" value="${val}" id="lt-${i}">
      <div class="hint"><span>0s instant</span><span>600s (10 min)</span></div>
    `;
    container.appendChild(row);
    // Wire immediately
    document.getElementById(`lt-${i}`).addEventListener('input', function() {
      laneTime[i] = +this.value;
      document.getElementById(`lt-v-${i}`).textContent = this.value + 's';
    });
  }
}

// ── Button wiring ──────────────────────────────
document.getElementById('btnRun').addEventListener('click', startStop);
document.getElementById('btnReset').addEventListener('click', reset);

// ── Global sliders ─────────────────────────────
document.getElementById('cLanes').addEventListener('input', function() {
  P.numLanes = +this.value;
  document.getElementById('vLanes').textContent = this.value;
  while (laneTime.length < P.numLanes) laneTime.push(30);
  reset();
});
document.getElementById('cArrival').addEventListener('input', function() {
  P.arrivalRate = +this.value;
  document.getElementById('vArrival').textContent = this.value;
});
document.getElementById('cSimSpeed').addEventListener('input', function() {
  P.simSpeed = +this.value;
  document.getElementById('vSimSpeed').textContent = this.value + '×';
});

// ── Toggle buttons ─────────────────────────────
document.querySelectorAll('[data-queue]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('[data-queue]').forEach(b => b.classList.remove('on'));
    btn.classList.add('on');
    P.queueType = btn.dataset.queue;
    reset();
  });
});
document.querySelectorAll('[data-mix]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('[data-mix]').forEach(b => b.classList.remove('on'));
    btn.classList.add('on');
    P.custMix = btn.dataset.mix;
  });
});

// ═══════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════
buildLayout();
buildLaneSliders();
renderFrame();
</script>
</body>
</html>
